<!DOCTYPE html>
<html>
<head>
  <title>Rogue Tactics</title>
  <meta charset="UTF-8">
  <style>
  html, body {
    height: 100%;
    margin: 0;
  }

  body {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas {
    border: 1px solid black;
  }
  </style>
</head>
<body>
<canvas width="320" height="480" id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d')

context.font = "30px Arial";
context.textAlign = "center";
context.fillStyle = 'blue';

let premadeMaps = [
    {
        w:[{x:7, y:1}, {x:1, y:9}, {x:7, y:11}, {x:1, y:12}],
        exit:{x:6, y:13},
        b:{x:0, y:0},
        t:{x:9, y:5},
        e:[{x:2, y:2}, {x:5, y:2}, {x:3, y:4}],
        p:[{x:3, y:12}, {x:2, y:13}, {x:4, y:13}]
    },
    {
        w:[{x:6, y:6}, {x:6, y:8}, {x:1, y:9}, {x:5, y:12}, {x:1, y:13}],
        exit:{x:5, y:4},
        b:{x:4, y:3},
        t:{x:0, y:0},
        e:[{x:3, y:6}, {x:8, y:7}, {x:2, y:11}],
        p:[{x:7, y:12}, {x:6, y:13}, {x:8, y:13}]
    },
    {
        w:[{x:9, y:4}, {x:4, y:8}, {x:0, y:10}, {x:7, y:10}],
        exit:{x:4, y:10},
        b:{x:6, y:1},
        t:{x:9, y:7},
        e:[{x:3, y:1}, {x:4, y:3}, {x:7, y:4}, {x:2, y:5}],
        p:[{x:3, y:12}, {x:2, y:13}, {x:4, y:13}]
    },
    {
        w:[{x:2, y:0}, {x:6, y:2}, {x:8, y:2}, {x:3, y:5}],
        exit:{x:5, y:13},
        b:{x:2, y:2},
        t:{x:7, y:1},
        e:[{x:7, y:6}, {x:1, y:7}, {x:1, y:13}],
        p:[{x:9, y:11}, {x:8, y:12}, {x:9, y:13}]
    },
    {
        w:[{x:5, y:8}, {x:5, y:10}, {x:8, y:13}, {x:6, y:14}],
        exit:{x:6, y:13},
        b:{x:8, y:3},
        t:{x:0, y:3},
        e:[{x:5, y:2}, {x:5, y:4}, {x:6, y:5}, {x:8, y:6}],
        p:[{x:2, y:12}, {x:1, y:13}, {x:3, y:13}]
    },
    {
        w:[{x:5, y:0}, {x:3, y:2}, {x:2, y:4}, {x:5, y:6}, {x:3, y:14}],
        exit:{x:0, y:8},
        b:{x:9, y:14},
        t:{x:0, y:0},
        e:[{x:1, y:0}, {x:8, y:2}, {x:4, y:12}],
        p:[{x:2, y:7}, {x:3, y:8}, {x:2, y:9}]
    },
    {
        w:[{x:2, y:5}, {x:2, y:8}, {x:9, y:12}, {x:8, y:14}],
        exit:{x:8, y:13},
        b:{x:4, y:1},
        t:{x:0, y:11},
        e:[{x:5, y:4}, {x:6, y:4}, {x:4, y:6}, {x:8, y:6}],
        p:[{x:8, y:12}, {x:7, y:13}, {x:9, y:13}]
    },
    {
        w:[{x:1, y:0}, {x:7, y:4}, {x:9, y:6}, {x:7, y:8}, {x:0, y:9}],
        exit:{x:8, y:11},
        b:{x:7, y:6},
        t:{x:0, y:5},
        e:[{x:2, y:4}, {x:3, y:8}, {x:6, y:10}],
        p:[{x:1, y:13}, {x:0, y:14}, {x:2, y:14}]
    },
    {
        w:[{x:2, y:0}, {x:3, y:3}, {x:1, y:6}, {x:8, y:10}, {x:1, y:14}],
        exit:{x:5, y:11},
        b:{x:1, y:2},
        t:{x:8, y:3},
        e:[{x:5, y:2}, {x:6, y:5}, {x:1, y:8}],
        p:[{x:6, y:12}, {x:5, y:13}, {x:7, y:13}]
    },
    {
        w:[{x:5, y:0}, {x:3, y:1}, {x:9, y:1}, {x:0, y:2}, {x:2, y:10}],
        exit:{x:8, y:14},
        b:{x:7, y:12},
        t:{x:1, y:1},
        e:[{x:7, y:7}, {x:4, y:10}, {x:1, y:13}],
        p:[{x:1, y:5}, {x:2, y:6}, {x:1, y:7}]
    },
    {
        w:[{x:9, y:1}, {x:4, y:2}, {x:4, y:3}, {x:1, y:4}, {x:5, y:4}],
        exit:{x:0, y:1},
        b:{x:3, y:13},
        t:{x:8, y:1},
        e:[{x:3, y:10}, {x:1, y:12}, {x:5, y:12}],
        p:[{x:2, y:4}, {x:4, y:4}, {x:3, y:5}]
    },
    {
        w:[{x:2, y:1}, {x:5, y:6}, {x:4, y:8}, {x:0, y:14}],
        exit:{x:2, y:5},
        b:{x:7, y:13},
        t:{x:9, y:1},
        e:[{x:1, y:10}, {x:8, y:10}, {x:3, y:13}],
        p:[{x:3, y:2}, {x:4, y:3}, {x:3, y:4}]
    },
    {
        w:[{x:7, y:1}, {x:4, y:7}, {x:1, y:12}, {x:5, y:12}],
        exit:{x:1, y:13},
        b:{x:0, y:0},
        t:{x:9, y:7},
        e:[{x:6, y:1}, {x:2, y:2}, {x:0, y:3}, {x:5, y:4}],
        p:[{x:3, y:10}, {x:2, y:11}, {x:4, y:11}]
    },
    {
        w:[{x:3, y:5}, {x:3, y:7}, {x:8, y:9}, {x:3, y:12}],
        exit:{x:8, y:4},
        b:{x:0, y:14},
        t:{x:3, y:1},
        e:[{x:0, y:9}, {x:4, y:10}, {x:7, y:13}],
        p:[{x:4, y:5}, {x:6, y:5}, {x:5, y:6}]
    }
];




let closeCombatArchetype = {range:1, movement:3, maxhp:20, hp:20, attack:4, defense:2, speed:3};
let distanceArchetype = {range:2, movement:2, maxhp:18, hp:18, attack:3, defense:3, speed:2};
let supportArchetype = {range:2, movement:2, maxhp:15, hp:15, attack:1, defense:0, speed:1};

let archetypes = [closeCombatArchetype, distanceArchetype, supportArchetype];

function statsRange(ref)
{
  let res = Math.floor(Math.random() * 4) + ref - 1;
  if (res < 0)
    res = 0;
  return res;
}

class Unit {
  constructor(type, binding) {
    this.type = type;
    this.range = archetypes[type].range;
    this.movement = archetypes[type].movement;
    this.maxhp = statsRange(archetypes[type].maxhp);
    this.hp = this.maxhp;
    this.attack = statsRange(archetypes[type].attack);
    this.defense = statsRange(archetypes[type].defense);
    this.speed = statsRange(archetypes[type].speed);
    this.exp = 0;
    this.ability = [];
    this.binding = binding;
  }
}

let playerUnits = [];
for (let i = 0; i < 3; i++)
  playerUnits.push(new Unit(Math.floor(Math.random() * 3), i));
let enemyUnits = [];
let boss;
let thief;

let grid = [];
for (let i = 0; i < 15; i++)
  for (let j = 0; j < 10; j++)
    grid.push({x:j * 32, y:i * 32, danger:false, highlight:0});
let map;

let tileImage = new Image();
tileImage.src = "tileset.png";

function coordinate(x, y) {
  return y * 10 + x;
}





function isWall(x, y) {
  for (let i = 0; i < map.w.length; i++)
    if (map.w[i].x == x && map.w[i].y == y)
      return true;
  return false;
}

function validCoordinates(x, y)
{
  if (x < 0 || x > 9 || y < 0 || y > 14)
    return false;
  return true;
}

function fillNodeD(start, movex, movey, r) {
  if (!validCoordinates(start.x, start.y) || isWall(start.x, start.y))
    return;

  if (movey == 0 && movex == 0) {
    grid[start.y * 10 + start.x].danger = true;

    if (start.x - r >= 0 && !isWall(start.x - r, start.y))
      grid[start.y * 10 + (start.x - r)].danger = true;
    if (start.y + r < 15 && !isWall(start.x, start.y + r))
      grid[(start.y + r) * 10 + start.x].danger = true;
    if (start.x + r < 10 && !isWall(start.x + r, start.y))
      grid[start.y * 10 + (start.x + r)].danger = true;
    if (start.y - r >= 0 && !isWall(start.x, start.y - r))
      grid[(start.y - r) * 10 + start.x].danger = true;

    if (r == 2) {
      if (start.x - 1 >= 0 && start.y + 1 < 15 && !isWall(start.x - 1, start.y + 1))
        grid[(start.y + 1) * 10 + (start.x - 1)].danger = true;
      if (start.x - 1 >= 0 && start.y - 1 >= 0 && !isWall(start.x - 1, start.y - 1))
        grid[(start.y - 1) * 10 + (start.x - 1)].danger = true;
      if (start.x + 1 < 10 && start.y + 1 < 15 && !isWall(start.x + 1, start.y + 1))
        grid[(start.y + 1) * 10 + (start.x + 1)].danger = true;
      if (start.x + 1 < 10 && start.y - 1 >= 0 && !isWall(start.x + 1, start.y - 1))
        grid[(start.y - 1) * 10 + (start.x + 1)].danger = true;
    }
    return;
  }
  let stepy = (movey < 0) ? -1 : 1;
  let stepx = (movex < 0) ? -1 : 1;
  if (Math.abs(movey) > Math.abs(movex) && movey != 0 && validCoordinates(start.x, start.y + stepy) && !isWall(start.x, start.y + stepy))
    fillNodeD({x:start.x, y:start.y + stepy}, movex, movey - stepy, r);
  else if (movex != 0 && !isWall(start.x + stepx, start.y))
    fillNodeD({x:start.x + stepx, y:start.y}, movex - stepx, movey, r);
  else if (movey != 0 && !isWall(start.x, start.y + stepy))
    fillNodeD({x:start.x, y:start.y + stepy}, movex, movey - stepy, r);
}

function fillDanger(start, m, r) {
  grid[start.y * 10 + start.x].danger = true;
  if (start.x - r >= 0 && !isWall(start.x - r, start.y))
    grid[start.y * 10 + (start.x - r)].danger = true;
  if (start.y + r < 15 && !isWall(start.x, start.y + r))
    grid[(start.y + r) * 10 + start.x].danger = true;
  if (start.x + r < 10 && !isWall(start.x + r, start.y))
    grid[start.y * 10 + (start.x + r)].danger = true;
  if (start.y - r >= 0 && !isWall(start.x, start.y - r))
    grid[(start.y - r) * 10 + start.x].danger = true;

  if (r == 2) {
    if (start.x - 1 >= 0 && start.y + 1 < 15 && !isWall(start.x - 1, start.y + 1))
      grid[(start.y + 1) * 10 + (start.x - 1)].danger = true;
    if (start.x - 1 >= 0 && start.y - 1 >= 0 && !isWall(start.x - 1, start.y - 1))
      grid[(start.y - 1) * 10 + (start.x - 1)].danger = true;
    if (start.x + 1 < 10 && start.y + 1 < 15 && !isWall(start.x + 1, start.y + 1))
      grid[(start.y + 1) * 10 + (start.x + 1)].danger = true;
    if (start.x + 1 < 10 && start.y - 1 >= 0 && !isWall(start.x + 1, start.y - 1))
      grid[(start.y - 1) * 10 + (start.x + 1)].danger = true;
  }
  for (let max = m; max > 0; max--) {
    for (let i = -max; i < max + 1; i++) {
      let j = max - Math.abs(i);
      fillNodeD(start, j, i, r);
      fillNodeD(start, -j, i, r);
    }
  }
}



let selected = -1;

function fillNodeP(start, movex, movey, r) {
  if (!validCoordinates(start.x, start.y) || isWall(start.x, start.y))
    return;

  if (movey == 0 && movex == 0) {
    grid[start.y * 10 + start.x].highlight = 1;

    if (start.x - r >= 0 && !isWall(start.x - r, start.y) && grid[start.y * 10 + (start.x - r)].highlight != 1)
      grid[start.y * 10 + (start.x - r)].highlight = 2;
    if (start.y + r < 15 && !isWall(start.x, start.y + r) && grid[(start.y + r) * 10 + start.x].highlight != 1)
      grid[(start.y + r) * 10 + start.x].highlight = 2;
    if (start.x + r < 10 && !isWall(start.x + r, start.y) && grid[start.y * 10 + (start.x + r)].highlight != 1)
      grid[start.y * 10 + (start.x + r)].highlight = 2;
    if (start.y - r >= 0 && !isWall(start.x, start.y - r) && grid[(start.y - r) * 10 + start.x].highlight != 1)
      grid[(start.y - r) * 10 + start.x].highlight = 2;

    if (r == 2) {
      if (start.x - 1 >= 0 && start.y + 1 < 15 && !isWall(start.x - 1, start.y + 1) && grid[(start.y + 1) * 10 + (start.x - 1)].highlight != 1)
        grid[(start.y + 1) * 10 + (start.x - 1)].highlight = 2;
      if (start.x - 1 >= 0 && start.y - 1 >= 0 && !isWall(start.x - 1, start.y - 1) && grid[(start.y - 1) * 10 + (start.x - 1)].highlight != 1)
        grid[(start.y - 1) * 10 + (start.x - 1)].highlight = 2;
      if (start.x + 1 < 10 && start.y + 1 < 15 && !isWall(start.x + 1, start.y + 1) && grid[(start.y + 1) * 10 + (start.x + 1)].highlight != 1)
        grid[(start.y + 1) * 10 + (start.x + 1)].highlight = 2;
      if (start.x + 1 < 10 && start.y - 1 >= 0 && !isWall(start.x + 1, start.y - 1) && grid[(start.y - 1) * 10 + (start.x + 1)].highlight != 1)
        grid[(start.y - 1) * 10 + (start.x + 1)].highlight = 2;
    }
    return;
  }
  let stepy = (movey < 0) ? -1 : 1;
  let stepx = (movex < 0) ? -1 : 1;
  if (Math.abs(movey) > Math.abs(movex) && movey != 0 && validCoordinates(start.x, start.y + stepy) && !isWall(start.x, start.y + stepy))
    fillNodeP({x:start.x, y:start.y + stepy}, movex, movey - stepy, r);
  else if (movex != 0 && !isWall(start.x + stepx, start.y))
    fillNodeP({x:start.x + stepx, y:start.y}, movex - stepx, movey, r);
  else if (movey != 0 && !isWall(start.x, start.y + stepy))
    fillNodeP({x:start.x, y:start.y + stepy}, movex, movey - stepy, r);
}

function fillPlayer(start, m, r) {
  grid[start.y * 10 + start.x].highlight = 1;
  if (start.x - r >= 0 && !isWall(start.x - r, start.y))
    grid[start.y * 10 + (start.x - r)].highlight = 2;
  if (start.y + r < 15 && !isWall(start.x, start.y + r))
    grid[(start.y + r) * 10 + start.x].highlight = 2;
  if (start.x + r < 10 && !isWall(start.x + r, start.y))
    grid[start.y * 10 + (start.x + r)].highlight = 2;
  if (start.y - r >= 0 && !isWall(start.x, start.y - r))
    grid[(start.y - r) * 10 + start.x].highlight = 2;

  if (r == 2) {
    if (start.x - 1 >= 0 && start.y + 1 < 15 && !isWall(start.x - 1, start.y + 1))
      grid[(start.y + 1) * 10 + (start.x - 1)].highlight = 2;
    if (start.x - 1 >= 0 && start.y - 1 >= 0 && !isWall(start.x - 1, start.y - 1))
      grid[(start.y - 1) * 10 + (start.x - 1)].highlight = 2;
    if (start.x + 1 < 10 && start.y + 1 < 15 && !isWall(start.x + 1, start.y + 1))
      grid[(start.y + 1) * 10 + (start.x + 1)].highlight = 2;
    if (start.x + 1 < 10 && start.y - 1 >= 0 && !isWall(start.x + 1, start.y - 1))
      grid[(start.y - 1) * 10 + (start.x + 1)].highlight = 2;
  }
  for (let max = m; max > 0; max--) {
    for (let i = -max; i < max + 1; i++) {
      let j = max - Math.abs(i);
      fillNodeP(start, j, i, r);
      fillNodeP(start, -j, i, r);
    }
  }
}



function dangerZone() {
  for (let i = 0; i < grid.length; i++)
    grid[i].danger = false;
  enemyUnits.forEach(function(enemy) {
    fillDanger(map.e[enemy.binding], enemy.movement, enemy.range);
  });
  fillDanger(map.b, boss.movement, boss.range);
  fillDanger(map.t, thief.movement, thief.range);
}

function generateNewMap() {
  let select = Math.floor(Math.random() * premadeMaps.length);
  map = premadeMaps[select];
  enemyUnits = [];
  for (let i = 0; i < map.e.length; i++)
    enemyUnits.push(new Unit(Math.floor(Math.random() * 3), i));
  thief = new Unit(0, 0);
  boss = new Unit(Math.floor(Math.random() * 2), 0);
  boss.attack += 2;
  boss.defense += 2;
  boss.maxhp += 2;
  boss.hp += 2;
  boss.movement = 0;
  boss.speed += 2;
  dangerZone();
}

let end = false;
let menu = false;

generateNewMap();


function loop() {
  requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);
  if (menu) {
    context.fillText("tap to start", canvas.width / 2, canvas.height - 10);
  } else if (!end) {
    for (let i = 0; i < grid.length; i++) {
      context.drawImage(tileImage, 0, 0, 32, 32, grid[i].x, grid[i].y, 32, 32);
      if (grid[i].danger)
        context.drawImage(tileImage, 7 * 32, 0, 32, 32, grid[i].x, grid[i].y, 32, 32);
      if (grid[i].highlight == 1)
        context.drawImage(tileImage, 8 * 32, 0, 32, 32, grid[i].x, grid[i].y, 32, 32);
      if (grid[i].highlight == 2)
        context.drawImage(tileImage, 9 * 32, 0, 32, 32, grid[i].x, grid[i].y, 32, 32);
    }
    for (let i = 0; i < map.w.length; i++)
      context.drawImage(tileImage, 2 * 32, 0, 32, 32, grid[coordinate(map.w[i].x, map.w[i].y)].x, grid[coordinate(map.w[i].x, map.w[i].y)].y, 32, 32);
    context.drawImage(tileImage, 32, 0, 32, 32, grid[coordinate(map.exit.x, map.exit.y)].x, grid[coordinate(map.exit.x, map.exit.y)].y, 32, 32);
    context.drawImage(tileImage, 5* 32, 0, 32, 32, grid[coordinate(map.b.x, map.b.y)].x, grid[coordinate(map.b.x, map.b.y)].y, 32, 32);
    for (let i = 0; i < map.e.length; i++)
      context.drawImage(tileImage, 4 * 32, 0, 32, 32, grid[coordinate(map.e[i].x, map.e[i].y)].x, grid[coordinate(map.e[i].x, map.e[i].y)].y, 32, 32);
    for (let i = 0; i < map.p.length; i++)
      context.drawImage(tileImage, 3 * 32, 0, 32, 32, grid[coordinate(map.p[i].x, map.p[i].y)].x, grid[coordinate(map.p[i].x, map.p[i].y)].y, 32, 32);
    context.drawImage(tileImage, 6* 32, 0, 32, 32, grid[coordinate(map.t.x, map.t.y)].x, grid[coordinate(map.t.x, map.t.y)].y, 32, 32);

    for (let i = 0; i < playerUnits.length; i++)
      context.drawImage(tileImage, (11 + playerUnits[i].type) * 32, 0, 32, 32, grid[coordinate(map.p[playerUnits[i].binding].x, map.p[playerUnits[i].binding].y)].x, grid[coordinate(map.p[playerUnits[i].binding].x, map.p[playerUnits[i].binding].y)].y, 32, 32);
    for (let i = 0; i < enemyUnits.length; i++)
      context.drawImage(tileImage, (11 + enemyUnits[i].type) * 32, 0, 32, 32, grid[coordinate(map.e[enemyUnits[i].binding].x, map.e[enemyUnits[i].binding].y)].x, grid[coordinate(map.e[enemyUnits[i].binding].x, map.e[enemyUnits[i].binding].y)].y, 32, 32);
    context.drawImage(tileImage, (11 + boss.type) * 32, 0, 32, 32, grid[coordinate(map.b.x, map.b.y)].x, grid[coordinate(map.b.x, map.b.y)].y, 32, 32);
  } else {
    context.font = "20px Arial";
    context.fillText("tap to restart", canvas.width / 2, canvas.height - 10);
  }
}

function findUnit(pos) {
  for (let i = 0; i < playerUnits.length; i++)
    if (map.p[playerUnits[i].binding].x == pos.x && map.p[playerUnits[i].binding].y == pos.y)
      return i;
  return -1;
}

document.addEventListener('click', function(e) {
  let relativeX = e.x - canvas.offsetLeft;
  let relativeY = e.y - canvas.offsetTop;

  if (menu) {
    menu = false;
    return;
  }
  if (end) {
    menu = true;
    end = false;
  } else {
    if (grid[Math.floor(relativeY / 32) * 10 + Math.floor(relativeX / 32)].highlight == 0 || findUnit({y:Math.floor(relativeY / 32), x:Math.floor(relativeX / 32)}) != -1)
      for (let i = 0 ; i < grid.length; i++)
        grid[i].highlight = 0;
    map.p.forEach(function(pos) {
      if (relativeX >= pos.x * 32 && relativeX < (pos.x + 1) * 32 && relativeY >= pos.y * 32 && relativeY < (pos.y + 1) * 32) {
        selected = findUnit(pos);
        if (selected != -1)
          fillPlayer(pos, playerUnits[selected].movement, playerUnits[selected].range);
      }
    });
  }
});

requestAnimationFrame(loop);
</script>
</body>
</html>